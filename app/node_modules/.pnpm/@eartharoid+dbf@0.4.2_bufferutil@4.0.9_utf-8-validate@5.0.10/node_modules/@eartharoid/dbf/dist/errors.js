"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameworkTypeError = exports.FrameworkRangeError = exports.FrameworkError = void 0;
const util_1 = require("util");
const messages = {
    ComponentAlreadyLoaded: (id, mod) => `A component with the ID "${id}" is already loaded by the "${mod}" module`,
    InvalidCommandType: (type) => `"${type}" is not a valid command type`,
    InvalidCustomId: (id) => `Failed to parse invalid component customId: "${id}"`,
    InvalidType: (name, expected, actual) => `Expected "${name}" to be of type "${expected}", but got "${actual}"`,
    ModLoadingError: (mod, error) => `The "${mod}" module encountered an error whilst loading components:\n${(0, util_1.inspect)(error)}`,
    UnknownComponent: (id, mod) => `"${id}" is not a valid component loaded by the "${mod}" module`,
    UnknownModule: (id, mod) => `The component with the ID "${id}" does not belong to a valid module ("${mod}")`,
};
class FrameworkError extends Error {
    constructor(id, ...values) {
        const message = messages[id](...values);
        super(message);
        this.name = `Error [${id}]`;
    }
}
exports.FrameworkError = FrameworkError;
class FrameworkRangeError extends RangeError {
    constructor(id, ...values) {
        const message = messages[id](...values);
        super(message);
        this.name = `RangeError [${id}]`;
    }
}
exports.FrameworkRangeError = FrameworkRangeError;
class FrameworkTypeError extends TypeError {
    constructor(id, ...values) {
        const message = messages[id](...values);
        super(message);
        this.name = `TypeError [${id}]`;
    }
}
exports.FrameworkTypeError = FrameworkTypeError;
