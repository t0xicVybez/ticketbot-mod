"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Transport_1 = __importDefault(require("../../Transport"));
const deep_merge_1 = __importDefault(require("@eartharoid/deep-merge"));
const defaults_1 = __importDefault(require("./defaults"));
const console_1 = require("console");
const dtf_1 = __importDefault(require("@eartharoid/dtf"));
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const dtf = new dtf_1.default('en-GB');
class FileTransport extends Transport_1.default {
    constructor(options = {}) {
        const merged = (0, deep_merge_1.default)(defaults_1.default, options);
        super({ level: merged.level });
        this.options = merged;
    }
    _prepareFile() {
        this.today = dtf.fill('YYYY-MM-DD');
        if (!fs_1.default.existsSync((0, path_1.resolve)(this.options.directory))) {
            fs_1.default.mkdirSync((0, path_1.resolve)(this.options.directory));
        }
        if (this.options.clean_directory >= 0) {
            const one_day = 1000 * 60 * 60 * 24;
            const files = fs_1.default.readdirSync((0, path_1.resolve)(this.options.directory)).filter(file => file.endsWith('.log'));
            const date = Date.now();
            for (const file of files) {
                const path = (0, path_1.join)(this.options.directory, `/${file}`);
                const last_mod = new Date(fs_1.default.statSync(path).mtime).valueOf();
                const old = Math.floor((date - last_mod) / one_day) > this.options.clean_directory;
                if (old)
                    fs_1.default.unlinkSync(path);
            }
        }
        if (this.stream)
            this.stream.end();
        const file = typeof this.options.file === 'function' ? this.options.file() : dtf.fill(this.options.file);
        const path = (0, path_1.join)((0, path_1.resolve)(this.options.directory), file);
        this.stream = fs_1.default.createWriteStream(path, { flags: 'a' }); // 'a' flag to append instead of overwriting
        this.file = new console_1.Console({
            stderr: this.stream,
            stdout: this.stream,
        });
        const header = typeof this.options.header === 'function' ? this.options.header.call(this.options) : this.options.header;
        this.file.log(header);
    }
    write(log) {
        if (!this.file)
            this._prepareFile();
        if (this.options.new_file.toLowerCase() === 'day' && this.today !== dtf.fill('YYYY-MM-DD'))
            this._prepareFile();
        const content = typeof this.options.format === 'function'
            ? this.options.format.call(this.options, log)
            : this.options.format
                .replace(/{+ ?level ?}+/gm, log.level.name.toLowerCase())
                .replace(/{+ ?LEVEL ?}+/gm, log.level.name.toUpperCase())
                .replace(/{+ ?namespace ?}+/gm, log.namespace?.toLowerCase() ?? 'global')
                .replace(/{+ ?NAMESPACE ?}+/gm, log.namespace?.toUpperCase() ?? 'GLOBAL')
                .replace(/{+ ?file ?}+/gmi, log.file ?? 'unknown')
                .replace(/{+ ?line ?}+/gmi, String(log.line) ?? 'unknown')
                .replace(/{+ ?column ?}+/gmi, String(log.column) ?? 'unknown')
                .replace(/{+ ?content ?}+/gmi, log.content)
                .replace(/{+ ?timestamp ?}+/gmi, typeof this.options.timestamp === 'function'
                ? this.options.timestamp(log.timestamp)
                : dtf.fill(this.options.timestamp, log.timestamp));
        // escape ANSI formatting
        this.file[log.level.type](content.replace(/\u001b\[.*?m/g, '')); // eslint-disable-line no-control-regex
    }
}
exports.default = FileTransport;
