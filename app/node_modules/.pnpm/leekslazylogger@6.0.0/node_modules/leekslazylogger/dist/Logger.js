"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Logger_instances, _Logger_options, _Logger_init;
Object.defineProperty(exports, "__esModule", { value: true });
const deep_merge_1 = __importDefault(require("@eartharoid/deep-merge"));
const defaults_1 = __importDefault(require("./defaults"));
const path_1 = require("path");
const util_1 = require("util");
class Logger {
    constructor(options = {}) {
        _Logger_instances.add(this);
        _Logger_options.set(this, void 0);
        // (this.constructor as typeof Logger)
        __classPrivateFieldSet(this, _Logger_options, (0, deep_merge_1.default)(Logger.defaults, options), "f");
        this.levels = Object.keys(__classPrivateFieldGet(this, _Logger_options, "f").levels);
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_init).call(this);
    }
    log(namespace, level, ...content) {
        const _prepareStackTrace = Error.prepareStackTrace; // eslint-disable-line no-underscore-dangle
        Error.prepareStackTrace = (_, stack) => stack;
        const stack = new Error().stack;
        const callsite = stack ? stack[2] : null;
        Error.prepareStackTrace = _prepareStackTrace;
        for (const transport of __classPrivateFieldGet(this, _Logger_options, "f").transports) {
            if (level.number >= this.levels.indexOf(transport.level)) {
                transport.write({
                    column: callsite ? callsite.getColumnNumber() : null,
                    content: (0, util_1.format)(...content),
                    file: callsite?.getFileName() ? (0, path_1.relative)(process.cwd(), callsite?.getFileName()) : null,
                    level,
                    line: callsite ? callsite.getLineNumber() : null,
                    namespace,
                    timestamp: new Date(),
                });
            }
        }
    }
    get options() {
        return __classPrivateFieldGet(this, _Logger_options, "f");
    }
    set options(options) {
        __classPrivateFieldSet(this, _Logger_options, (0, deep_merge_1.default)(__classPrivateFieldGet(this, _Logger_options, "f"), options), "f");
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_init).call(this);
    }
}
_Logger_options = new WeakMap(), _Logger_instances = new WeakSet(), _Logger_init = function _Logger_init() {
    this.levels = Object.keys(__classPrivateFieldGet(this, _Logger_options, "f").levels);
    if (__classPrivateFieldGet(this, _Logger_options, "f").transports.length < 1)
        throw new Error('At least one logger transport is required. Remove `transports` from your options to use the defaults.');
    for (const level in __classPrivateFieldGet(this, _Logger_options, "f").levels) {
        const log_level = {
            name: level,
            number: this.levels.indexOf(level),
            type: __classPrivateFieldGet(this, _Logger_options, "f").levels[level],
        };
        this[level] = (...content) => this.log(null, log_level, ...content);
        for (const namespace of __classPrivateFieldGet(this, _Logger_options, "f").namespaces) {
            this[level][namespace] = (...content) => this.log(namespace, log_level, ...content);
        }
    }
};
Logger.defaults = defaults_1.default;
exports.default = Logger;
